# shoppingmall
商店为了促销往往将若干个商品捆绑在一起以低于商品原来的价格进行销售，这样可以鼓励顾客购买更多的商品。请帮助顾客计算他最少能以多少的价格才能购买到他所需的商品。注意，他不希望购买的商品与他的要求不符，也就是他购买的商品既不能多也不能少。
输入要求：
输入的第一行包含一个整数n（0<=n<=5），表示该顾客需要购买的商品的信息。其后的n行，每一行有三个整数c (1 <= c <= 999),k(1 <= k <= 5),p (1 <= p <= 999)，分别表示商品的编号c，购买该商品的数量k 以及该商品的单价p；之后的一行是一个整数m (0 <= m <= 99)，表示可以选择的优惠类型；其后的m行，每一行表示一种优惠类型。每一行的第一个数是一个整数s (1 <= s <= 5)，表示该种优惠包含多少个可以捆绑在一起的优惠商品，每一个捆绑的商品都包含该商品的编号c以及对应的数量h(1 <= h <= 5), 最后一个是该种捆绑优惠的商品的总价格t(1 <= t <= 9999)。比如某种捆绑优惠包含2种不同的商品，第一种商品的编号为7，数量为1，第二种商品的编号为8，数量为2，总的价格为10，则该种捆绑优惠可表示为：
2 7 1 8 2 10
输出要求：
输出一个整数，占一行，表示购买所需商品的最低价格。
输入样例：
2
7 3 2
8 2 5
2
1 7 3 5
2 7 1 8 2 10
输出样例：
14



算法设计思路：因为没有设置大礼包的使用次数，所以将大礼包视为无限次使用，参考力扣上的大礼包算法，采用完全背包加记忆搜索的方法来解决问题。
首先第一种情况，状态方程为：
dp[need]=min{price[i]+dp[need-need[i]]}
其中， i表示其中一个大礼包的下标, price;表示第个大礼包的价格，needs;表示大礼包中包含的物品清单，need-need[i];表示购物清单needs减去第i个大礼包中包含的物品清单后剩余的物品清单。
第二种情况是不购买任何大礼包，原价购买购物清单中的所有物品，此时dp[need]可以直接求出。
边界函数就是need<need[i]，大礼包无法再次购买（因为购买后会多），只能一个一个购买


算法时间复杂度：
T(n)=n*k*m^n,  其中k表示大礼包种类，m表示需求量的可能值，n表示物品种类
